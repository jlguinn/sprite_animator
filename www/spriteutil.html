<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sprite Sheet Animator</title>
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background-color: #f4f7fa;
      color: #333;
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
    }
    .container {
      max-width: 800px;
      width: 100%;
      background-color: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    h3 {
      margin-top: 0;
      color: #2c3e50;
    }
    .input-group {
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    label {
      font-weight: bold;
      color: #34495e;
      min-width: 100px;
    }
    input[type="file"],
    input[type="number"] {
      padding: 8px;
      border: 1px solid #dcdcdc;
      border-radius: 4px;
      font-size: 14px;
    }
    input[type="number"] {
      width: 80px;
    }
    input[type="checkbox"] {
      margin-left: 10px;
    }
    button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      background-color: #3498db;
      color: white;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    button:hover:not(:disabled) {
      background-color: #2980b9;
    }
    button:disabled {
      background-color: #bdc3c7;
      cursor: not-allowed;
    }
    .canvas-container {
      display: flex;
      align-items: flex-start;
      gap: 15px;
      margin: 15px 0;
    }
    canvas {
      border: 2px solid #34495e;
      border-radius: 4px;
      background-color: #ecf0f1;
    }
    .controls-container {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    .movement-controls,
    .global-controls {
      display: grid;
      grid-template-areas:
        ". up ."
        "left reset right"
        ". down .";
      gap: 5px;
    }
    .movement-btn {
      padding: 5px;
      font-size: 12px;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #3498db;
    }
    .movement-btn:hover:not(:disabled) {
      background-color: #2980b9;
    }
    .movement-btn.up { grid-area: up; }
    .movement-btn.down { grid-area: down; }
    .movement-btn.left { grid-area: left; }
    .movement-btn.right { grid-area: right; }
    .movement-btn.reset {
      grid-area: reset;
      background-color: #e74c3c;
    }
    .movement-btn.reset:hover:not(:disabled) {
      background-color: #c0392b;
    }
    .global-controls .movement-btn {
      background-color: #2ecc71;
    }
    .global-controls .movement-btn:hover:not(:disabled) {
      background-color: #27ae60;
    }
    .control-label {
      font-size: 12px;
      font-weight: bold;
      color: #34495e;
      text-align: center;
      margin-bottom: 5px;
    }
    .frame-position {
      text-align: center;
      font-size: 14px;
      color: #34495e;
      margin-bottom: 15px;
    }
    pre {
      background-color: #f8f9fa;
      padding: 15px;
      border: 1px solid #dcdcdc;
      border-radius: 4px;
      max-height: 300px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      color: #2c3e50;
    }
    .json-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="input-group">
      <label>Sprite Sheet (PNG):</label>
      <input type="file" id="spriteInput" accept="image/png">
    </div>
    <div class="input-group">
      <label>Rows:</label>
      <input type="number" id="rowsInput" value="5" min="1">
      <label>Columns:</label>
      <input type="number" id="colsInput" value="5" min="1">
    </div>
    <div class="input-group">
      <label>Speed (FPS):</label>
      <input type="number" id="speedInput" value="60" min="1" max="120">
    </div>
    <div class="input-group">
      <label>Overlay Previous Frame:</label>
      <input type="checkbox" id="overlayToggle">
    </div>
    <div class="input-group">
      <label>Load JSON Config:</label>
      <input type="file" id="jsonInput" accept="application/json">
    </div>
    <div class="input-group">
      <button id="pauseResumeBtn" disabled>Pause</button>
      <button id="prevFrameBtn" disabled>Previous Frame</button>
      <button id="nextFrameBtn" disabled>Next Frame</button>
    </div>
    <div class="canvas-container">
      <canvas id="previewCanvas"></canvas>
      <div class="controls-container">
        <div>
          <div class="control-label">Frame Adjustment</div>
          <div class="movement-controls">
            <button class="movement-btn up" id="moveUpBtn" disabled>↑</button>
            <button class="movement-btn left" id="moveLeftBtn" disabled>←</button>
            <button class="movement-btn reset" id="resetBtn" disabled>Reset</button>
            <button class="movement-btn right" id="moveRightBtn" disabled>→</button>
            <button class="movement-btn down" id="moveDownBtn" disabled>↓</button>
          </div>
        </div>
        <div>
          <div class="control-label">Global Adjustment</div>
          <div class="global-controls">
            <button class="movement-btn up" id="globalMoveUpBtn" disabled>↑</button>
            <button class="movement-btn left" id="globalMoveLeftBtn" disabled>←</button>
            <button class="movement-btn reset" id="globalResetBtn" disabled>Reset</button>
            <button class="movement-btn right" id="globalMoveRightBtn" disabled>→</button>
            <button class="movement-btn down" id="globalMoveDownBtn" disabled>↓</button>
          </div>
        </div>
      </div>
    </div>
    <div class="frame-position" id="framePosition">Row: -, Col: -</div>
    <div>
      <h3>Frame Specifications</h3>
      <div class="json-controls">
        <button id="copyJsonBtn" disabled>Copy JSON</button>
      </div>
      <pre id="frameSpecs"></pre>
    </div>
  </div>

  <script>
    const spriteInput = document.getElementById('spriteInput');
    const rowsInput = document.getElementById('rowsInput');
    const colsInput = document.getElementById('colsInput');
    const speedInput = document.getElementById('speedInput');
    const jsonInput = document.getElementById('jsonInput');
    const overlayToggle = document.getElementById('overlayToggle');
    const pauseResumeBtn = document.getElementById('pauseResumeBtn');
    const prevFrameBtn = document.getElementById('prevFrameBtn');
    const nextFrameBtn = document.getElementById('nextFrameBtn');
    const moveUpBtn = document.getElementById('moveUpBtn');
    const moveDownBtn = document.getElementById('moveDownBtn');
    const moveLeftBtn = document.getElementById('moveLeftBtn');
    const moveRightBtn = document.getElementById('moveRightBtn');
    const resetBtn = document.getElementById('resetBtn');
    const globalMoveUpBtn = document.getElementById('globalMoveUpBtn');
    const globalMoveDownBtn = document.getElementById('globalMoveDownBtn');
    const globalMoveLeftBtn = document.getElementById('globalMoveLeftBtn');
    const globalMoveRightBtn = document.getElementById('globalMoveRightBtn');
    const globalResetBtn = document.getElementById('globalResetBtn');
    const copyJsonBtn = document.getElementById('copyJsonBtn');
    const canvas = document.getElementById('previewCanvas');
    const ctx = canvas.getContext('2d');
    const frameSpecsOutput = document.getElementById('frameSpecs');
    const framePosition = document.getElementById('framePosition');

    let spriteImage = null;
    let frames = [];
    let currentFrame = 0;
    let isPaused = false;
    let lastFrameTime = 0;
    let globalOffsetX = 0; // Global x-axis adjustment
    let globalOffsetY = 0; // Global y-axis adjustment
    let overlayEnabled = false; // Track overlay state
    const moveIncrement = 1; // Pixels to move per click

    // Load sprite sheet
    spriteInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        spriteImage = new Image();
        spriteImage.onload = () => {
          updateAnimation();
          // Enable controls
          pauseResumeBtn.disabled = false;
          prevFrameBtn.disabled = false;
          nextFrameBtn.disabled = false;
          moveUpBtn.disabled = false;
          moveDownBtn.disabled = false;
          moveLeftBtn.disabled = false;
          moveRightBtn.disabled = false;
          resetBtn.disabled = false;
          globalMoveUpBtn.disabled = false;
          globalMoveDownBtn.disabled = false;
          globalMoveLeftBtn.disabled = false;
          globalMoveRightBtn.disabled = false;
          globalResetBtn.disabled = false;
          copyJsonBtn.disabled = false;
        };
        spriteImage.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    // Load JSON configuration
    jsonInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file || !spriteImage) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const config = JSON.parse(event.target.result);
          const rows = parseInt(rowsInput.value) || 5;
          const cols = parseInt(colsInput.value) || 5;
          const expectedFrameCount = rows * cols;

          // Validate the loaded JSON
          if (!config.frames || !Array.isArray(config.frames)) {
            alert('Invalid JSON: "frames" must be an array.');
            return;
          }
          if (config.frames.length !== expectedFrameCount) {
            alert(`Invalid JSON: Expected ${expectedFrameCount} frames, but found ${config.frames.length}.`);
            return;
          }
          if (typeof config.globalOffsetX !== 'number' || typeof config.globalOffsetY !== 'number') {
            alert('Invalid JSON: "globalOffsetX" and "globalOffsetY" must be numbers.');
            return;
          }

          // Validate frame structure and dimensions
          const frameWidth = spriteImage.width / cols;
          const frameHeight = spriteImage.height / rows;
          for (let i = 0; i < config.frames.length; i++) {
            const frame = config.frames[i];
            if (typeof frame.x !== 'number' || typeof frame.y !== 'number' ||
                typeof frame.width !== 'number' || typeof frame.height !== 'number' ||
                typeof frame.offsetX !== 'number' || typeof frame.offsetY !== 'number') {
              alert(`Invalid JSON: Frame ${i} is missing required properties or has invalid types.`);
              return;
            }
            // Check if dimensions match the current sprite sheet
            if (Math.abs(frame.width - frameWidth) > 0.1 || Math.abs(frame.height - frameHeight) > 0.1) {
              alert(`Invalid JSON: Frame ${i} dimensions (${frame.width}x${frame.height}) do not match expected dimensions (${frameWidth}x${frameHeight}).`);
              return;
            }
          }

          // Apply the loaded configuration
          frames = config.frames;
          globalOffsetX = config.globalOffsetX;
          globalOffsetY = config.globalOffsetY;

          // Update display
          frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY }, null, 2);
          currentFrame = 0;
          drawFrame();
        } catch (error) {
          alert('Error parsing JSON: ' + error.message);
        }
      };
      reader.readAsText(file);
    });

    // Copy JSON to clipboard
    copyJsonBtn.addEventListener('click', () => {
      if (frames.length === 0) return;

      const config = { frames, globalOffsetX, globalOffsetY };
      const jsonString = JSON.stringify(config, null, 2);
      navigator.clipboard.writeText(jsonString).then(() => {
        alert('JSON copied to clipboard!');
      }).catch((error) => {
        alert('Failed to copy JSON: ' + error.message);
      });
    });

    // Toggle overlay
    overlayToggle.addEventListener('change', () => {
      overlayEnabled = overlayToggle.checked;
      console.log('Overlay toggled:', overlayEnabled); // Debug log
      drawFrame();
    });

    // Update frames when inputs change
    rowsInput.addEventListener('input', updateAnimation);
    colsInput.addEventListener('input', updateAnimation);

    function updateAnimation() {
      if (!spriteImage) return;

      const rows = parseInt(rowsInput.value) || 5;
      const cols = parseInt(colsInput.value) || 5;

      // Calculate frame dimensions
      const frameWidth = spriteImage.width / cols;
      const frameHeight = spriteImage.height / rows;

      // Generate frame specifications with per-frame offsets
      frames = [];
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          frames.push({
            x: col * frameWidth,
            y: row * frameHeight,
            width: frameWidth,
            height: frameHeight,
            offsetX: 0, // Per-frame x offset
            offsetY: 0  // Per-frame y offset
          });
        }
      }

      // Update canvas size to match single frame
      canvas.width = frameWidth;
      canvas.height = frameHeight;

      // Reset global adjustments
      globalOffsetX = 0;
      globalOffsetY = 0;

      // Display frame specs
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY }, null, 2);

      // Reset animation
      currentFrame = 0;
      drawFrame();
    }

    // Draw current frame with per-frame and global position adjustments
    function drawFrame() {
      if (frames.length === 0) {
        framePosition.textContent = "Row: -, Col: -";
        return;
      }

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw current frame first with full opacity
      const frame = frames[currentFrame];
      const totalOffsetX = frame.offsetX + globalOffsetX;
      const totalOffsetY = frame.offsetY + globalOffsetY;
      ctx.globalAlpha = 1.0; // Ensure full opacity
      ctx.drawImage(
        spriteImage,
        frame.x, frame.y, frame.width, frame.height,
        totalOffsetX, totalOffsetY, canvas.width, canvas.height
      );

      // Draw previous frame on top with 50% opacity if overlay is enabled
      if (overlayEnabled) {
        const prevFrameIndex = (currentFrame - 1 + frames.length) % frames.length;
        const prevFrame = frames[prevFrameIndex];
        const prevTotalOffsetX = prevFrame.offsetX + globalOffsetX;
        const prevTotalOffsetY = prevFrame.offsetY + globalOffsetY;

        ctx.globalAlpha = 0.5; // Set 50% opacity for previous frame
        ctx.drawImage(
          spriteImage,
          prevFrame.x, prevFrame.y, prevFrame.width, prevFrame.height,
          prevTotalOffsetX, prevTotalOffsetY, canvas.width, canvas.height
        );
        ctx.globalAlpha = 1.0; // Reset opacity
      }

      // Calculate row and column (1-based for display)
      const cols = parseInt(colsInput.value) || 5;
      const row = Math.floor(currentFrame / cols) + 1;
      const col = (currentFrame % cols) + 1;
      framePosition.textContent = `Row: ${row}, Col: ${col}`;
    }

    // Animation loop
    function animate(timestamp) {
      if (isPaused || frames.length === 0) {
        requestAnimationFrame(animate);
        return;
      }

      // Calculate time since last frame
      const fps = parseInt(speedInput.value) || 60;
      const frameInterval = 1000 / fps;

      if (timestamp - lastFrameTime >= frameInterval) {
        // Advance frame
        currentFrame = (currentFrame + 1) % frames.length;
        drawFrame();
        lastFrameTime = timestamp - (timestamp % frameInterval);
      }

      requestAnimationFrame(animate);
    }

    // Start animation loop
    requestAnimationFrame(animate);

    // Speed input handler
    speedInput.addEventListener('input', () => {
      const fps = parseInt(speedInput.value);
      if (fps < 1 || fps > 120) speedInput.value = 60; // Basic validation
      lastFrameTime = performance.now(); // Reset timing
    });

    // Pause/Resume handler
    pauseResumeBtn.addEventListener('click', () => {
      isPaused = !isPaused;
      pauseResumeBtn.textContent = isPaused ? 'Resume' : 'Pause';
    });

    // Previous frame handler
    prevFrameBtn.addEventListener('click', () => {
      if (frames.length === 0) return;
      currentFrame = (currentFrame - 1 + frames.length) % frames.length;
      drawFrame();
    });

    // Next frame handler
    nextFrameBtn.addEventListener('click', () => {
      if (frames.length === 0) return;
      currentFrame = (currentFrame + 1) % frames.length;
      drawFrame();
    });

    // Per-frame movement handlers
    moveUpBtn.addEventListener('click', () => {
      if (frames.length === 0) return;
      frames[currentFrame].offsetY -= moveIncrement;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY }, null, 2);
      drawFrame();
    });

    moveDownBtn.addEventListener('click', () => {
      if (frames.length === 0) return;
      frames[currentFrame].offsetY += moveIncrement;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY }, null, 2);
      drawFrame();
    });

    moveLeftBtn.addEventListener('click', () => {
      if (frames.length === 0) return;
      frames[currentFrame].offsetX -= moveIncrement;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY }, null, 2);
      drawFrame();
    });

    moveRightBtn.addEventListener('click', () => {
      if (frames.length === 0) return;
      frames[currentFrame].offsetX += moveIncrement;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY }, null, 2);
      drawFrame();
    });

    resetBtn.addEventListener('click', () => {
      if (frames.length === 0) return;
      frames[currentFrame].offsetX = 0;
      frames[currentFrame].offsetY = 0;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY }, null, 2);
      drawFrame();
    });

    // Global movement handlers
    globalMoveUpBtn.addEventListener('click', () => {
      globalOffsetY -= moveIncrement;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY }, null, 2);
      drawFrame();
    });

    globalMoveDownBtn.addEventListener('click', () => {
      globalOffsetY += moveIncrement;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY }, null, 2);
      drawFrame();
    });

    globalMoveLeftBtn.addEventListener('click', () => {
      globalOffsetX -= moveIncrement;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY }, null, 2);
      drawFrame();
    });

    globalMoveRightBtn.addEventListener('click', () => {
      globalOffsetX += moveIncrement;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY }, null, 2);
      drawFrame();
    });

    globalResetBtn.addEventListener('click', () => {
      globalOffsetX = 0;
      globalOffsetY = 0;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY }, null, 2);
      drawFrame();
    });
  </script>
</body>
</html>