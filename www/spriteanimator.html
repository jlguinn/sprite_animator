<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sprite Sheet Animator</title>
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background-color: #f4f7fa;
      color: #333;
      margin: 0;
      padding: 20px;
      display: flex;
      justify-content: center;
    }
    .container {
      max-width: 800px;
      width: 100%;
      background-color: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    h3 {
      margin-top: 0;
      color: #2c3e50;
    }
    .input-group {
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    label {
      font-weight: bold;
      color: #34495e;
      min-width: 100px;
    }
    input[type="file"],
    input[type="number"] {
      padding: 8px;
      border: 1px solid #dcdcdc;
      border-radius: 4px;
      font-size: 14px;
    }
    input[type="number"] {
      width: 80px;
    }
    input[type="checkbox"] {
      margin-left: 10px;
    }
    button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      background-color: #3498db;
      color: white;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    button:hover:not(:disabled) {
      background-color: #2980b9;
    }
    button:disabled {
      background-color: #bdc3c7;
      cursor: not-allowed;
    }
    .canvas-wrapper {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }
    .canvas-container {
      display: flex;
      align-items: flex-start;
      gap: 15px;
      margin: 15px 0;
    }
    .frame-wrapper {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 5px;
    }
    canvas {
      border: 2px solid #34495e;
      border-radius: 4px;
      background-color: #ecf0f1;
    }
    .controls-wrapper {
      display: flex;
      align-items: flex-start;
      gap: 15px;
    }
    .controls-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: center;
    }
    .movement-controls,
    .global-controls {
      display: grid;
      grid-template-areas:
        ". up ."
        "left reset right"
        ". down .";
      gap: 3px;
    }
    .movement-btn {
      padding: 3px;
      font-size: 10px;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #3498db;
    }
    .movement-btn:hover:not(:disabled) {
      background-color: #2980b9;
    }
    .movement-btn.up { grid-area: up; }
    .movement-btn.down { grid-area: down; }
    .movement-btn.left { grid-area: left; }
    .movement-btn.right { grid-area: right; }
    .movement-btn.reset {
      grid-area: reset;
      background-color: #e74c3c;
    }
    .movement-btn.reset:hover:not(:disabled) {
      background-color: #c0392b;
    }
    .global-controls .movement-btn {
      background-color: #2ecc71;
    }
    .global-controls .movement-btn:hover:not(:disabled) {
      background-color: #27ae60;
    }
    .control-label {
      font-size: 12px;
      font-weight: bold;
      color: #34495e;
      text-align: center;
      margin-bottom: 5px;
    }
    .frame-position {
      font-size: 14px;
      color: #34495e;
    }
    .json-output {
      max-height: 200px;
      width: 300px;
      overflow-y: auto;
      background-color: #f8f9fa;
      padding: 10px;
      border: 1px solid #dcdcdc;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      color: #2c3e50;
      cursor: pointer;
    }
    .json-input-group {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    textarea#jsonInput {
      width: 100%;
      height: 150px;
      padding: 10px;
      border: 1px solid #dcdcdc;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      resize: vertical;
    }
    #resetFrameBtn {
      margin-left: 10px; /* Extra spacing to set it apart */
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="input-group">
      <label>Sprite Sheet (v0.016):</label>
      <input type="file" id="spriteInput" accept="image/png">
    </div>
    <div class="input-group">
      <label>Rows:</label>
      <input type="number" id="rowsInput" value="5" min="1">
      <label>Columns:</label>
      <input type="number" id="colsInput" value="5" min="1">
    </div>
    <div class="input-group">
      <label>Delay (ms):</label>
      <input type="text" id="speedInput" value="125">
    </div>
    <div class="input-group">
      <label>Overlay Previous Frame:</label>
      <input type="checkbox" id="overlayToggle">
    </div>
    <div class="input-group">
      <button id="prevFrameBtn" disabled>|&lt;</button>
      <button id="pauseResumeBtn" disabled>||</button>
      <button id="nextFrameBtn" disabled>&gt;|</button>
      <button id="resetFrameBtn" disabled>&#8634;</button>
    </div>    
    <div class="canvas-wrapper">
      <div class="canvas-container">
        <div class="frame-wrapper">
          <canvas id="previewCanvas"></canvas>
          <div class="frame-position" id="framePosition">-</div>
        </div>
        <div class="controls-wrapper">
          <div class="controls-container">
            <div>
              <div class="control-label">Frame Adjustment</div>
              <div class="movement-controls">
                <button class="movement-btn up" id="moveUpBtn" disabled>↑</button>
                <button class="movement-btn left" id="moveLeftBtn" disabled>←</button>
                <button class="movement-btn reset" id="resetBtn" disabled>Reset</button>
                <button class="movement-btn right" id="moveRightBtn" disabled>→</button>
                <button class="movement-btn down" id="moveDownBtn" disabled>↓</button>
              </div>
            </div>
            <div>
              <div class="control-label">Global Adjustment</div>
              <div class="global-controls">
                <button class="movement-btn up" id="globalMoveUpBtn" disabled>↑</button>
                <button class="movement-btn left" id="globalMoveLeftBtn" disabled>←</button>
                <button class="movement-btn reset" id="globalResetBtn" disabled>Reset</button>
                <button class="movement-btn right" id="globalMoveRightBtn" disabled>→</button>
                <button class="movement-btn down" id="globalMoveDownBtn" disabled>↓</button>
              </div>
            </div>
          </div>
          <pre id="frameSpecs" class="json-output" onclick="this.focus(); const range = document.createRange(); range.selectNodeContents(this); const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range);">-</pre>
        </div>
      </div>
      <div>
        <h3>JSON Configuration</h3>
        <div class="json-input-group">
          <textarea id="jsonInput" placeholder="Paste JSON configuration here..."></textarea>
          <button id="applyJsonBtn" disabled>Apply</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    const spriteInput = document.getElementById('spriteInput');
    const rowsInput = document.getElementById('rowsInput');
    const colsInput = document.getElementById('colsInput');
    const speedInput = document.getElementById('speedInput');
    const jsonInput = document.getElementById('jsonInput');
    const applyJsonBtn = document.getElementById('applyJsonBtn');
    const overlayToggle = document.getElementById('overlayToggle');
    const pauseResumeBtn = document.getElementById('pauseResumeBtn');
    const prevFrameBtn = document.getElementById('prevFrameBtn');
    const nextFrameBtn = document.getElementById('nextFrameBtn');
    const moveUpBtn = document.getElementById('moveUpBtn');
    const moveDownBtn = document.getElementById('moveDownBtn');
    const moveLeftBtn = document.getElementById('moveLeftBtn');
    const moveRightBtn = document.getElementById('moveRightBtn');
    const resetBtn = document.getElementById('resetBtn');
    const globalMoveUpBtn = document.getElementById('globalMoveUpBtn');
    const globalMoveDownBtn = document.getElementById('globalMoveDownBtn');
    const globalMoveLeftBtn = document.getElementById('globalMoveLeftBtn');
    const globalMoveRightBtn = document.getElementById('globalMoveRightBtn');
    const globalResetBtn = document.getElementById('globalResetBtn');
    const canvas = document.getElementById('previewCanvas');
    const ctx = canvas.getContext('2d');
    const frameSpecsOutput = document.getElementById('frameSpecs');
    const framePosition = document.getElementById('framePosition');
  
    let spriteImage = null;
    let frames = [];
    let currentFrame = 0;
    let isPaused = false;
    let lastFrameTime = 0;
    let globalOffsetX = 0;
    let globalOffsetY = 0;
    let overlayEnabled = false;
    const moveIncrement = 1;
  
    // Load sprite sheet
    spriteInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
  
      const reader = new FileReader();
      reader.onload = (event) => {
        spriteImage = new Image();
        spriteImage.onload = () => {
          updateAnimation();
          // Enable controls
          pauseResumeBtn.disabled = false;
          prevFrameBtn.disabled = false;
          nextFrameBtn.disabled = false;
          resetFrameBtn.disabled = false;
          moveUpBtn.disabled = false;
          moveDownBtn.disabled = false;
          moveLeftBtn.disabled = false;
          moveRightBtn.disabled = false;
          resetBtn.disabled = false;
          globalMoveUpBtn.disabled = false;
          globalMoveDownBtn.disabled = false;
          globalMoveLeftBtn.disabled = false;
          globalMoveRightBtn.disabled = false;
          globalResetBtn.disabled = false;
          applyJsonBtn.disabled = false;
        };
        spriteImage.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });
  
    applyJsonBtn.addEventListener('click', () => {
      if (!spriteImage) return;

      try {
        const config = JSON.parse(jsonInput.value);
        const rows = parseInt(rowsInput.value) || 5;
        const cols = parseInt(colsInput.value) || 5;
        const expectedFrameCount = rows * cols;

        // Validate the loaded JSON
        if (!config.frames || !Array.isArray(config.frames)) {
          alert('Invalid JSON: "frames" must be an array.');
          return;
        }
        if (config.frames.length !== expectedFrameCount) {
          alert(`Invalid JSON: Expected ${expectedFrameCount} frames, but found ${config.frames.length}.`);
          return;
        }
        if (typeof config.globalOffsetX !== 'number' || typeof config.globalOffsetY !== 'number') {
          alert('Invalid JSON: "globalOffsetX" and "globalOffsetY" must be numbers.');
          return;
        }
        if (typeof config.delayMs !== 'number' || config.delayMs <= 0) {
          alert('Invalid JSON: "delayMs" must be a positive number.');
          return;
        }

        // Validate frame structure and dimensions
        const frameWidth = Math.round(spriteImage.width / cols);
        const frameHeight = Math.round(spriteImage.height / rows);
        for (let i = 0; i < config.frames.length; i++) {
          const frame = config.frames[i];
          if (typeof frame.x !== 'number' || typeof frame.y !== 'number' ||
              typeof frame.width !== 'number' || typeof frame.height !== 'number' ||
              typeof frame.offsetX !== 'number' || typeof frame.offsetY !== 'number') {
            alert(`Invalid JSON: Frame ${i} is missing required properties or has invalid types.`);
            return;
          }
          const jsonFrameWidth = Math.round(frame.width);
          const jsonFrameHeight = Math.round(frame.height);
          if (jsonFrameWidth !== frameWidth || jsonFrameHeight !== frameHeight) {
            alert(`Invalid JSON: Frame ${i} dimensions (${jsonFrameWidth}x${jsonFrameHeight}) do not match expected dimensions (${frameWidth}x${frameHeight}).`);
            return;
          }
        }

        // Apply the loaded configuration
        frames = config.frames;
        globalOffsetX = config.globalOffsetX;
        globalOffsetY = config.globalOffsetY;
        speedInput.value = config.delayMs; // Set delayMs directly

        // Update display
        frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY, delayMs: config.delayMs, loop: true }, null, 2);
        currentFrame = 0;
        drawFrame();
      } catch (error) {
        alert('Error parsing JSON: ' + error.message);
      }
    });
  
    // Toggle overlay
    overlayToggle.addEventListener('change', () => {
      overlayEnabled = overlayToggle.checked;
      drawFrame();
    });
  
    // Update frames when inputs change
    rowsInput.addEventListener('input', updateAnimation);
    colsInput.addEventListener('input', updateAnimation);
    speedInput.addEventListener('change', updateDelay);
    speedInput.addEventListener('blur', updateDelay);

    function updateDelay() {
      let delayMs = parseInt(speedInput.value);
      if (isNaN(delayMs) || delayMs < 8 || delayMs > 1000) {
        delayMs = 125; // Default to 125 ms
        speedInput.value = delayMs;
      }
      lastFrameTime = performance.now();
      updateAnimation(); // Update JSON with new delayMs
    }
  
    function updateAnimation() {
      if (!spriteImage) return;

      const rows = parseInt(rowsInput.value) || 5;
      const cols = parseInt(colsInput.value) || 5;
      const delayMs = parseInt(speedInput.value) || 125;

      // Calculate frame dimensions (rounded for crisp rendering)
      const frameWidth = Math.round(spriteImage.width / cols);
      const frameHeight = Math.round(spriteImage.height / rows);

      // Check if frames array is compatible (same number of frames)
      const expectedFrameCount = rows * cols;
      let newFrames = [];
      if (frames.length === expectedFrameCount) {
        // Preserve existing offsets if frame count matches
        for (let i = 0; i < frames.length; i++) {
          const row = Math.floor(i / cols);
          const col = i % cols;
          newFrames.push({
            x: col * frameWidth,
            y: row * frameHeight,
            width: frameWidth,
            height: frameHeight,
            offsetX: frames[i].offsetX || 0,
            offsetY: frames[i].offsetY || 0
          });
        }
      } else {
        // Generate new frames if frame count has changed or frames are empty
        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            newFrames.push({
              x: col * frameWidth,
              y: row * frameHeight,
              width: frameWidth,
              height: frameHeight,
              offsetX: 0,
              offsetY: 0
            });
          }
        }
        // Reset global offsets only if frame count changes
        globalOffsetX = 0;
        globalOffsetY = 0;
      }

      // Update frames array
      frames = newFrames;

      // Update canvas size to match single frame
      canvas.width = frameWidth;
      canvas.height = frameHeight;

      // Display frame specs with delayMs and loop
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY, delayMs, loop: true }, null, 2);

      // Reset animation to current frame
      currentFrame = Math.min(currentFrame, frames.length - 1);
      drawFrame();
    }
  
    // Draw current frame with per-frame and global position adjustments
    function drawFrame() {
      if (frames.length === 0) {
        framePosition.textContent = "-";
        return;
      }
  
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
  
      // Draw current frame first with full opacity
      const frame = frames[currentFrame];
      const totalOffsetX = frame.offsetX + globalOffsetX;
      const totalOffsetY = frame.offsetY + globalOffsetY;
      ctx.globalAlpha = 1.0;
      ctx.drawImage(
        spriteImage,
        frame.x, frame.y, frame.width, frame.height,
        totalOffsetX, totalOffsetY, canvas.width, canvas.height
      );
  
      // Draw previous frame on top with 50% opacity if overlay is enabled
      if (overlayEnabled) {
        const prevFrameIndex = (currentFrame - 1 + frames.length) % frames.length;
        const prevFrame = frames[prevFrameIndex];
        const prevTotalOffsetX = prevFrame.offsetX + globalOffsetX;
        const prevTotalOffsetY = prevFrame.offsetY + globalOffsetY;
  
        ctx.globalAlpha = 0.5;
        ctx.drawImage(
          spriteImage,
          prevFrame.x, prevFrame.y, prevFrame.width, prevFrame.height,
          prevTotalOffsetX, prevTotalOffsetY, canvas.width, canvas.height
        );
        ctx.globalAlpha = 1.0;
      }
  
      // Calculate row and column (1-based for display)
      const cols = parseInt(colsInput.value) || 5;
      const row = Math.floor(currentFrame / cols) + 1;
      const col = (currentFrame % cols) + 1;
      framePosition.textContent = `${row}:${col}`;
    }
  
    // Animation loop
    function animate(timestamp) {
      if (isPaused || frames.length === 0) {
        requestAnimationFrame(animate);
        return;
      }

      // Calculate time since last frame
      const delayMs = parseInt(speedInput.value) || 125;
      if (timestamp - lastFrameTime >= delayMs) {
        currentFrame = (currentFrame + 1) % frames.length;
        drawFrame();
        lastFrameTime = timestamp - (timestamp % delayMs);
      }

      requestAnimationFrame(animate);
    }
  
    // Start animation loop
    requestAnimationFrame(animate);
  
    // Speed input handler
    speedInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        validateAndApplyDelay();
      }
    });
    speedInput.addEventListener('blur', validateAndApplyDelay);

    function validateAndApplyDelay() {
      const input = speedInput.value.trim();
      const delayMs = parseInt(input);
      if (isNaN(delayMs) || delayMs < 8 || delayMs > 1000 || input.match(/[^0-9]/)) {
        speedInput.value = '125'; // Default to 125 ms
      } else {
        speedInput.value = delayMs.toString(); // Ensure clean integer display
      }
      lastFrameTime = performance.now();
      updateAnimation(); // Update JSON with new delayMs
    }
  
    // Pause/Resume handler
    pauseResumeBtn.addEventListener('click', () => {
      isPaused = !isPaused;
      pauseResumeBtn.textContent = isPaused ? '>' : '||';
      if (!isPaused) {
        lastFrameTime = performance.now();
      }
    });
  
    // Previous frame handler
    prevFrameBtn.addEventListener('click', () => {
      if (frames.length === 0) return;
      currentFrame = (currentFrame - 1 + frames.length) % frames.length;
      drawFrame();
    });
  
    // Next frame handler
    nextFrameBtn.addEventListener('click', () => {
      if (frames.length === 0) return;
      currentFrame = (currentFrame + 1) % frames.length;
      drawFrame();
    });
  
    resetFrameBtn.addEventListener('click', () => {
      if (frames.length === 0) return;
      currentFrame = 0;
      drawFrame();
    });

    // Per-frame movement handlers
    moveUpBtn.addEventListener('click', () => {
      if (frames.length === 0) return;
      frames[currentFrame].offsetY -= moveIncrement;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY, delayMs: 1000 / (parseInt(speedInput.value) || 60), loop: true }, null, 2);
      drawFrame();
    });
  
    moveDownBtn.addEventListener('click', () => {
      if (frames.length === 0) return;
      frames[currentFrame].offsetY += moveIncrement;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY, delayMs: 1000 / (parseInt(speedInput.value) || 60), loop: true }, null, 2);
      drawFrame();
    });
  
    moveLeftBtn.addEventListener('click', () => {
      if (frames.length === 0) return;
      frames[currentFrame].offsetX -= moveIncrement;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY, delayMs: 1000 / (parseInt(speedInput.value) || 60), loop: true }, null, 2);
      drawFrame();
    });
  
    moveRightBtn.addEventListener('click', () => {
      if (frames.length === 0) return;
      frames[currentFrame].offsetX += moveIncrement;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY, delayMs: 1000 / (parseInt(speedInput.value) || 60), loop: true }, null, 2);
      drawFrame();
    });
  
    resetBtn.addEventListener('click', () => {
      if (frames.length === 0) return;
      frames[currentFrame].offsetX = 0;
      frames[currentFrame].offsetY = 0;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY, delayMs: 1000 / (parseInt(speedInput.value) || 60), loop: true }, null, 2);
      drawFrame();
    });
  
    // Global movement handlers
    globalMoveUpBtn.addEventListener('click', () => {
      globalOffsetY -= moveIncrement;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY, delayMs: 1000 / (parseInt(speedInput.value) || 60), loop: true }, null, 2);
      drawFrame();
    });
  
    globalMoveDownBtn.addEventListener('click', () => {
      globalOffsetY += moveIncrement;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY, delayMs: 1000 / (parseInt(speedInput.value) || 60), loop: true }, null, 2);
      drawFrame();
    });
  
    globalMoveLeftBtn.addEventListener('click', () => {
      globalOffsetX -= moveIncrement;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY, delayMs: 1000 / (parseInt(speedInput.value) || 60), loop: true }, null, 2);
      drawFrame();
    });
  
    globalMoveRightBtn.addEventListener('click', () => {
      globalOffsetX += moveIncrement;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY, delayMs: 1000 / (parseInt(speedInput.value) || 60), loop: true }, null, 2);
      drawFrame();
    });
  
    globalResetBtn.addEventListener('click', () => {
      globalOffsetX = 0;
      globalOffsetY = 0;
      frameSpecsOutput.textContent = JSON.stringify({ frames, globalOffsetX, globalOffsetY, delayMs: 1000 / (parseInt(speedInput.value) || 60), loop: true }, null, 2);
      drawFrame();
    });
  </script>
</body>
</html>